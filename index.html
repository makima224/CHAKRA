<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Naruto Jutsu - Shinobi God Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 5%; width: 100%; text-align: center; color: #fff; z-index: 10; pointer-events: none; }
        h1 { font-size: 3rem; margin: 0; color: #ff9d00; text-shadow: 0 0 20px #ff4d00; }
        #status { font-size: 1.2rem; color: #00ffff; background: rgba(0,0,0,0.5); display: inline-block; padding: 5px 20px; border-radius: 20px; }
        #video-container {
            position: absolute;
            bottom: 2%;
            left: 18%;
            transform: translateX(-50%) scaleX(-1);
            width: 85vw;
            max-width: 450px;
            height: 42vh; 
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 20;
            background-color: #000; 
            border-radius: 25px;
            overflow: hidden;
        }
        video { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }
        /* Style pour le canvas de dessin des mains */
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 21;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="ui">
    <h1>ナルト- 疾風伝 JUTSU</h1>
    <div id="status">CONCENTREZ VOTRE CHAKRA...</div>
</div>

<div id="video-container">
    <video class="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
</div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- THREE.JS SETUP (Identique au tien) ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 130;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.8, 0.4, 0.85);
    composer.addPass(bloom);

    const COUNT = 18000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(COUNT * 3);
    const colors = new Float32Array(COUNT * 3);
    const targetPositions = new Float32Array(COUNT * 3);
    const targetColors = new Float32Array(COUNT * 3);
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const particles = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 1.3, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true }));
    scene.add(particles);

    // --- TES FORMULES (Suiton, Raiton, etc.) ---
    const updateJutsu = (type) => {
        for(let i=0; i<COUNT; i++) {
            let x, y, z, r, g, b;
            if(type === 'rasengan') {
                const phi = Math.acos(-1 + (2 * i) / COUNT);
                const theta = Math.sqrt(COUNT * Math.PI) * phi;
                const radius = i < COUNT * 0.2 ? Math.random() * 8 : 22 + Math.random() * 6;
                x = radius * Math.cos(theta) * Math.sin(phi); y = radius * Math.sin(theta) * Math.sin(phi); z = radius * Math.cos(phi);
                [r, g, b] = i < COUNT * 0.2 ? [1, 1, 1] : [0.2, 0.6, 1.0];
            } else if(type === 'suiton') { 
                const row = i / COUNT;
                x = (row - 0.5) * 450; y = Math.sin(row * 12) * 40 + Math.cos(row * 7) * 15; z = (Math.random() - 0.5) * 70 + Math.sin(row * 10) * 20;
                [r,g,b] = Math.random() > 0.88 ? [0.9, 0.95, 1.0] : [0.0, 0.2, 0.8];
            } else if(type === 'raiton') {
                const step = i % 300;
                if (step === 0) { x = (Math.random() - 0.5) * 180; y = 120; z = (Math.random() - 0.5) * 60; } 
                else { x = targetPositions[(i - 1) * 3] + (Math.random() - 0.5) * 18; y = targetPositions[(i - 1) * 3 + 1] - 5.0; z = targetPositions[(i - 1) * 3 + 2] + (Math.random() - 0.5) * 18; }
                [r, g, b] = [0.8, 0.95, 1.0];
            } else if(type === 'fuuton') {
                const isCore = i < COUNT * 0.2;
                if (isCore) {
                    const phi = Math.acos(-1 + (2 * i) / (COUNT * 0.2)); const theta = Math.sqrt(COUNT * 0.2 * Math.PI) * phi; const radius = Math.random() * 15;
                    x = radius * Math.cos(theta) * Math.sin(phi); y = radius * Math.sin(theta) * Math.sin(phi); z = (Math.random() - 0.5) * 10;
                } else {
                    const numArms = 4; const t = (i / COUNT); const angle = (i % numArms / numArms) * Math.PI * 2 + (t * 2.5);
                    const dist = 15 + t * 90; x = Math.cos(angle) * dist; y = Math.sin(angle) * dist; z = (Math.random() - 0.5) * 5;
                }
                [r, g, b] = [0.95, 1.0, 1.0];
            } else if(type === 'mokuton') { 
                const pID = Math.floor(i / (COUNT/9));
                x = ((pID % 3) - 1) * 85 + (Math.random() - 0.5) * 25; y = (i % (COUNT/9) / (COUNT/9)) * 200 - 100; z = (Math.floor(pID / 3) - 1) * 85 + (Math.random() - 0.5) * 25; 
                [r, g, b] = [0.25, 0.15, 0.05];
            } else {
                const rad = 120 + Math.random() * 50; const t = Math.random() * Math.PI * 2; const p = Math.random() * Math.PI;
                x = rad * Math.cos(t) * Math.sin(p); y = rad * Math.sin(t) * Math.sin(p); z = rad * Math.cos(p);
                [r, g, b] = [0.05, 0.1, 0.35]; 
            }
            targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
            targetColors[i*3] = r; targetColors[i*3+1] = g; targetColors[i*3+2] = b;
        }
    };

    // --- HAND TRACKING AVEC DESSIN ---
    const videoElement = document.querySelector('.input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusText = document.getElementById('status');
    let activeTech = 'neutral';
    let lastDetected = 'neutral';
    let frameCounter = 0;

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.75 });

    hands.onResults((results) => {
        // Ajuster la taille du canvas
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        let currentDetection = 'neutral';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            for (const landmarks of results.multiHandLandmarks) {
                // DESSIN DES LIGNES (Squelette)
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 4});
                drawLandmarks(canvasCtx, landmarks, {color: '#ff9d00', lineWidth: 1, radius: 3});

                // LOGIQUE JUTSU (Ton code)
                const isIndexUp = landmarks[8].y < landmarks[6].y;
                const isMiddleUp = landmarks[12].y < landmarks[10].y;
                const thumbSpread = Math.sqrt(Math.pow(landmarks[4].x - landmarks[9].x, 2) + Math.pow(landmarks[4].y - landmarks[9].y, 2));

                if (results.multiHandLandmarks.length === 2) currentDetection = 'mokuton';
                else if (isIndexUp && isMiddleUp) currentDetection = 'suiton';
                else if (isIndexUp && !isMiddleUp) currentDetection = (thumbSpread > 0.11) ? 'rasengan' : 'fuuton';
                else if (!isIndexUp && !isMiddleUp) currentDetection = 'raiton';
            }
        }

        if (currentDetection === lastDetected) frameCounter++;
        else { frameCounter = 0; lastDetected = currentDetection; }

        if (frameCounter >= 2 && currentDetection !== activeTech) {
            activeTech = currentDetection;
            statusText.innerText = activeTech.toUpperCase();
            updateJutsu(activeTech);
        }
        canvasCtx.restore();
    });

    const cameraInput = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraInput.start();

    // --- ANIMATION LOOP (Identique au tien) ---
    function animate() {
        requestAnimationFrame(animate);
        const pos = geometry.attributes.position.array;
        const col = geometry.attributes.color.array;
        const time = Date.now() * 0.002;

        for(let i=0; i<COUNT; i++) {
            let idx = i * 3;
            pos[idx] += (targetPositions[idx] - pos[idx]) * 0.25;
            pos[idx + 1] += (targetPositions[idx + 1] - pos[idx + 1]) * 0.25;
            pos[idx + 2] += (targetPositions[idx + 2] - pos[idx + 2]) * 0.25;
            col[idx] += (targetColors[idx] - col[idx]) * 0.25;
            col[idx + 1] += (targetColors[idx + 1] - col[idx + 1]) * 0.25;
            col[idx + 2] += (targetColors[idx + 2] - col[idx + 2]) * 0.25;

            if (activeTech === 'suiton') {
                pos[idx + 1] += Math.sin(pos[idx] * 0.05 + time * 5) * 15; 
            }
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;

        if(activeTech === 'rasengan') {
            particles.rotation.y += 0.8; particles.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*4, 0);
        } else if(activeTech === 'raiton') {
            particles.rotation.y += 1.2; particles.position.x = (Math.random() - 0.5) * 15;
        } else if(activeTech === 'fuuton') {
            particles.rotation.z += 0.4;
        } else {
            particles.rotation.y += 0.01; particles.position.set(0,0,0);
        }
        composer.render();
    }
    updateJutsu('neutral');
    animate();
</script>
</body>
</html>