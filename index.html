<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Naruto Jutsu - Shinobi God Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 5%; width: 100%; text-align: center; color: #fff; z-index: 10; pointer-events: none; }
        h1 { font-size: 3rem; margin: 0; color: #ff9d00; text-shadow: 0 0 20px #ff4d00; }
        #status { font-size: 1.2rem; color: #00ffff; background: rgba(0,0,0,0.5); display: inline-block; padding: 5px 20px; border-radius: 20px; }
        #video-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 240px; height: 180px; 
            border: 2px solid #333; border-radius: 10px;
            overflow: hidden; transform: scaleX(-1);
            z-index: 5;
        }
        video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="ui">
    <h1>ナルト- 疾風伝 JUTSU</h1>
    <div id="status">CONCENTREZ VOTRE CHAKRA...</div>
</div>

<div id="video-container">
    <video class="input_video" playsinline></video>
</div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 130;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.8, 0.4, 0.85);
    composer.addPass(bloom);

    const COUNT = 18000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(COUNT * 3);
    const colors = new Float32Array(COUNT * 3);
    const targetPositions = new Float32Array(COUNT * 3);
    const targetColors = new Float32Array(COUNT * 3);

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const particles = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 1.3, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true }));
    scene.add(particles);

    const updateJutsu = (type) => {
        for(let i=0; i<COUNT; i++) {
            let x, y, z, r, g, b;

            if(type === 'rasengan') {
                const phi = Math.acos(-1 + (2 * i) / COUNT);
                const theta = Math.sqrt(COUNT * Math.PI) * phi;
                const radius = i < COUNT * 0.2 ? Math.random() * 8 : 22 + Math.random() * 6;
                x = radius * Math.cos(theta) * Math.sin(phi);
                y = radius * Math.sin(theta) * Math.sin(phi);
                z = radius * Math.cos(phi);
                [r, g, b] = i < COUNT * 0.2 ? [1, 1, 1] : [0.2, 0.6, 1.0];
            } else if(type === 'fuuton') {
    const isCore = i < COUNT * 0.2; // 20% des particules pour la boule centrale
    if (isCore) {
        // Sphère centrale (Boule du Rasengan)
        const phi = Math.acos(-1 + (2 * i) / (COUNT * 0.2));
        const theta = Math.sqrt(COUNT * 0.2 * Math.PI) * phi;
        const radius = Math.random() * 15;
        x = radius * Math.cos(theta) * Math.sin(phi);
        y = radius * Math.sin(theta) * Math.sin(phi);
        z = (Math.random() - 0.5) * 10;
    } else {
        // Les bras en spirale incurvés
        const numArms = 4; // Nombre de pales
        const armIndex = i % numArms;
        const t = (i / COUNT); // Progression vers l'extérieur
        
        // Angle de base + courbure en spirale
        const spiralCurvature = 2.5; 
        const angle = (armIndex / numArms) * Math.PI * 2 + (t * spiralCurvature);
        
        const dist = 15 + t * 90; // Rayon qui s'éloigne du centre
        const thickness = (1 - t) * 20; // Plus large au centre, fin au bout
        
        x = Math.cos(angle) * dist + (Math.random() - 0.5) * thickness;
        y = Math.sin(angle) * dist + (Math.random() - 0.5) * thickness;
        z = (Math.random() - 0.5) * 5;
    }
    [r, g, b] = [0.95, 1.0, 1.0]; // Blanc pur éclatant
}else if(type === 'suiton') { 
                const row = i / COUNT;
                x = (row - 0.5) * 450; 
                y = Math.sin(row * 12) * 40 + Math.cos(row * 7) * 15; 
                z = (Math.random() - 0.5) * 70 + Math.sin(row * 10) * 20;
                [r,g,b] = Math.random() > 0.88 ? [0.9, 0.95, 1.0] : [0.0, 0.2, 0.8];
            } else if(type === 'raiton') {
                const step = i % 300;
                if (step === 0) { 
                    x = (Math.random() - 0.5) * 180; y = 120; z = (Math.random() - 0.5) * 60; 
                } else {
                    x = targetPositions[(i - 1) * 3] + (Math.random() - 0.5) * 18;
                    y = targetPositions[(i - 1) * 3 + 1] - 5.0; 
                    z = targetPositions[(i - 1) * 3 + 2] + (Math.random() - 0.5) * 18;
                }
                [r, g, b] = [0.8, 0.95, 1.0];
            } else if(type === 'mokuton') { 
                const pID = Math.floor(i / (COUNT/9));
                x = ((pID % 3) - 1) * 85 + (Math.random() - 0.5) * 25; 
                y = (i % (COUNT/9) / (COUNT/9)) * 200 - 100; 
                z = (Math.floor(pID / 3) - 1) * 85 + (Math.random() - 0.5) * 25; 
                [r, g, b] = [0.25, 0.15, 0.05];
            } else {
                const rad = 120 + Math.random() * 50;
                const t = Math.random() * Math.PI * 2;
                const p = Math.random() * Math.PI;
                x = rad * Math.cos(t) * Math.sin(p);
                y = rad * Math.sin(t) * Math.sin(p);
                z = rad * Math.cos(p);
                [r, g, b] = [0.05, 0.1, 0.35]; 
            }
            targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
            targetColors[i*3] = r; targetColors[i*3+1] = g; targetColors[i*3+2] = b;
        }
    };

    const videoElement = document.querySelector('.input_video');
    const statusText = document.getElementById('status');
    let activeTech = 'neutral';
    let lastDetected = 'neutral';
    let frameCounter = 0;

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.75 });

    hands.onResults((results) => {
        let currentDetection = 'neutral';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const h = results.multiHandLandmarks[0];
            const isIndexUp = h[8].y < h[6].y;
            const isMiddleUp = h[12].y < h[10].y;
            const thumbSpread = Math.sqrt(Math.pow(h[4].x - h[9].x, 2) + Math.pow(h[4].y - h[9].y, 2));

            if (results.multiHandLandmarks.length === 2) {
                currentDetection = 'mokuton';
            } else if (isIndexUp && isMiddleUp) {
                currentDetection = 'suiton';
            } else if (isIndexUp && !isMiddleUp) {
                currentDetection = (thumbSpread > 0.11) ? 'rasengan' : 'fuuton';
            } else if (!isIndexUp && !isMiddleUp) {
                currentDetection = 'raiton';
            }
        }
        if (currentDetection === lastDetected) frameCounter++;
        else { frameCounter = 0; lastDetected = currentDetection; }

        if (frameCounter >= 2 && currentDetection !== activeTech) {
            activeTech = currentDetection;
            statusText.innerText = activeTech.toUpperCase();
            updateJutsu(activeTech);
        }
    });

    new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 }).start();

function animate() {
        requestAnimationFrame(animate);
        const pos = geometry.attributes.position.array;
        const col = geometry.attributes.color.array;
        const time = Date.now() * 0.002; // Vitesse de l'ondulation

        for(let i=0; i<COUNT; i++) {
            let idx = i * 3;
            
            // 1. Transition fluide vers la forme cible
            pos[idx]     += (targetPositions[idx] - pos[idx]) * 0.25;
            pos[idx + 1] += (targetPositions[idx + 1] - pos[idx + 1]) * 0.25;
            pos[idx + 2] += (targetPositions[idx + 2] - pos[idx + 2]) * 0.25;
            
            col[idx]     += (targetColors[idx] - col[idx]) * 0.25;
            col[idx + 1] += (targetColors[idx + 1] - col[idx + 1]) * 0.25;
            col[idx + 2] += (targetColors[idx + 2] - col[idx + 2]) * 0.25;

            // 2. EFFET D'ONDULATION (Uniquement pour le Suiton)
            if (activeTech === 'suiton') {
                // On ajoute une vague sinusoïdale basée sur la position X
                // Formule : sin(PositionX * fréquence + temps) * amplitude
                const wave = Math.sin(pos[idx] * 0.05 + time * 5) * 15;
                pos[idx + 1] += wave; 
            }
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;

        // Gestion des rotations et effets globaux
        if(activeTech === 'rasengan') {
            particles.rotation.y += 0.8;
            particles.rotation.z += 0.4;
            particles.position.x = (Math.random() - 0.5) * 4;
            particles.position.y = (Math.random() - 0.5) * 4;
        } else if(activeTech === 'fuuton') {
    // Rotation Z ultra rapide pour l'effet de scie circulaire
    particles.rotation.z += 0.4; // Ajuste cette valeur si c'est trop rapide/lent
    particles.rotation.x = 0;   
    particles.rotation.y = 0;   
    particles.position.set(0,0,0);
    bloom.strength = 3.5; // Éclat maximal pour le blanc
}else if(activeTech === 'suiton') {
            particles.position.set(0,0,0); // On laisse l'ondulation interne faire le travail
            particles.rotation.x = 0.2;
            bloom.strength = 2.2;
        } else if(activeTech === 'raiton') {
            particles.rotation.y += 1.2;
            particles.position.set(0,0,0);
        } else {
            particles.rotation.y += 0.01;
            particles.position.set(0,0,0);
            bloom.strength = 2.8;
        }
        composer.render();
    }        requestAnimationFrame(animate);
        const pos = geometry.attributes.position.array;
        const col = geometry.attributes.color.array;

        for(let i=0; i<COUNT*3; i++) {
            pos[i] += (targetPositions[i] - pos[i]) * 0.25;
            col[i] += (targetColors[i] - col[i]) * 0.25;
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;

        if(activeTech === 'rasengan') {
            particles.rotation.y += 0.8;
            particles.rotation.z += 0.4;
            particles.rotation.x = 0;
            particles.position.x = (Math.random() - 0.5) * 4;
            particles.position.y = (Math.random() - 0.5) * 4;
        } else if(activeTech === 'fuuton') {
    // Rotation Z ultra rapide pour l'effet de scie circulaire
    particles.rotation.z += 0.4; // Ajuste cette valeur si c'est trop rapide/lent
    particles.rotation.x = 0;   
    particles.rotation.y = 0;   
    particles.position.set(0,0,0);
    bloom.strength = 3.5; // Éclat maximal pour le blanc
}
        else if(activeTech === 'suiton') {
            const fastTime = Date.now() * 0.015;
            particles.position.y = Math.sin(fastTime) * 10; 
            particles.position.x = Math.cos(fastTime * 0.5) * 5;
            particles.rotation.y = Math.sin(Date.now() * 0.002) * 0.3;
            particles.rotation.x = 0.05;
            bloom.strength = 2;
        } else if(activeTech === 'raiton') {
            particles.rotation.y += 1.2; // Rotation Raiton accélérée
            particles.position.x = (Math.random() - 0.5) * 15;
            particles.position.set(0,0,0);
        } else {
            particles.rotation.y += 0.01;
            particles.rotation.x = 0;
            particles.rotation.z = 0;
            particles.position.set(0,0,0);
            bloom.strength = 2.8;
        }
        composer.render();
    
    animate();
</script>
</body>
</html>